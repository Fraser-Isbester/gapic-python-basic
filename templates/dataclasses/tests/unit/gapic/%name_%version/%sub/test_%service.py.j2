{% extends "_base.py.j2" %}

{% block content %}
{% import "tests/unit/gapic/%name_%version/%sub/test_macros.j2" as test_macros %}

# try/except added for compatibility with python < 3.8
try:
    from unittest import mock
except ImportError:
    import mock

import grpc
from grpc.experimental import aio
{% if "rest" in opts.transport %}
from collections.abc import Iterable
import json
{% endif %}
import pytest
from proto.marshal.rules.dates import DurationRule, TimestampRule

{% if 'rest' in opts.transport %}
from requests import Response
from requests import Request, PreparedRequest
from requests.sessions import Session
{% endif %}

{# Import the service itself as well as every proto module that it imports. #}
{% filter sort_lines %}
import google.auth
from {{ (api.naming.module_namespace + (api.naming.versioned_module_name,) + service.meta.address.subpackage)|join(".") }}.services.{{ service.name|snake_case }} import {{ service.client_name }}
from {{ (api.naming.module_namespace + (api.naming.versioned_module_name,) + service.meta.address.subpackage)|join(".") }}.services.{{ service.name|snake_case }} import transports

from google.api_core import client_options
from google.api_core import exceptions as core_exceptions
from google.api_core import grpc_helpers
from google.api_core import grpc_helpers_async
{% if service.has_lro or service.has_extended_lro %}
from google.api_core import future
{% endif %}
{% if service.has_lro %}
from google.api_core import operation
from google.api_core import operations_v1
from google.longrunning import operations_pb2
{% if "rest" in opts.transport %}
from google.protobuf import json_format
{% endif %}{# rest transport #}
{% endif %}{# lro #}
{% if api.has_location_mixin %}
from google.cloud.location import locations_pb2
{% endif %}
{% if api.has_operations_mixin %}
from google.longrunning import operations_pb2
{% endif %}
from google.api_core import gapic_v1
{% for method in service.methods.values() %}
{% for ref_type in method.ref_types
   if not ((ref_type.ident.python_import.package == ('google', 'api_core') and ref_type.ident.python_import.module == 'operation')
           or ref_type.ident.python_import.package == ('google', 'protobuf') and ref_type.ident.python_import.module == 'empty_pb2') %}
{{ ref_type.ident.python_import }}
{% endfor %}
{% endfor %}
{% endfilter %}


def client_cert_source_callback():
    return b"cert bytes", b"key bytes"


def modify_default_endpoint(client):
    return "foo.googleapis.com" if ("localhost" in client.DEFAULT_ENDPOINT) else client.DEFAULT_ENDPOINT


def test_{{ service.client_name|snake_case }}_get_transport_class():
    transport = {{ service.client_name }}.get_transport_class()
    available_transports = [
        {% for transport_name in opts.transport %}
        transports.{{ service.name }}{{ transport_name.capitalize() }}Transport,
        {% endfor %}
    ]
    assert transport in available_transports

    transport = {{ service.client_name }}.get_transport_class("{{ opts.transport[0] }}")
    assert transport == transports.{{ service.name }}{{ opts.transport[0].capitalize() }}Transport


{% for method in service.methods.values() if 'grpc' in opts.transport %}{# method_name #}
{% if method.extended_lro %}
{{ test_macros.grpc_required_tests(method, service, full_extended_lro=True) }}

{% endif %}
{{ test_macros.grpc_required_tests(method, service) }}
{% endfor %} {# method in methods for grpc #}

{% for method in service.methods.values() if 'rest' in opts.transport %}
{% if method.extended_lro %}
{{ test_macros.rest_required_tests(method, service, full_extended_lro=True) }}

{% endif %}
{{ test_macros.rest_required_tests(method, service) }}

{% endfor -%} {#- method in methods for rest #}

{% for method in service.methods.values() if 'rest' in opts.transport and
    not method.http_options %}{% with method_name = method.name|snake_case + "_unary" if method.operation_service else method.name|snake_case %}
def test_{{ method_name }}_rest_error():
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
        transport='rest'
    )
    # Since a `google.api.http` annotation is required for using a rest transport
    # method, this should error.
    with pytest.raises(RuntimeError) as runtime_error:
        client.{{ method_name }}({})
    assert ("Cannot define a method without a valid 'google.api.http' annotation."
        in str(runtime_error.value))


{% endwith %}{# method_name #}
{% endfor %}{# for methods without http_options #}


def test_transport_instance():
    # A client may be instantiated with a custom transport instance.
    transport = transports.{{ service.name }}{{ opts.transport[0].capitalize() }}Transport(host="squid.clam.whelk")
    client = {{ service.client_name }}(transport=transport)
    assert client.transport is transport

{% if 'grpc' in opts.transport %}
{# TODO(dovs): parametrize this over async/sync grpc#}
def test_transport_get_channel():
    # A client may be instantiated with a custom transport instance.
    transport = transports.{{ service.name }}GrpcTransport(
        host="squid.clam.whelk",
    )
    channel = transport.grpc_channel
    assert channel
{% endif %}

@pytest.mark.parametrize("transport_name", [
    {% if "grpc" in opts.transport %}
    "grpc",
    {% endif %}
    {% if "rest" in opts.transport %}
    "rest",
    {% endif %}
])
def test_transport_kind(transport_name):
    transport = {{ service.client_name }}.get_transport_class(transport_name)()
    assert transport.kind == transport_name

{% if 'grpc' in opts.transport %}
def test_transport_grpc_default():
    # A client should use the gRPC transport by default.
    client = {{ service.client_name }}()
    assert isinstance(
        client.transport,
        transports.{{ service.name }}GrpcTransport,
    )
{% endif %}


def test_{{ service.name|snake_case }}_base_transport():
    # Instantiate the base transport.
    with mock.patch('{{ (api.naming.module_namespace + (api.naming.versioned_module_name,) + service.meta.address.subpackage)|join(".") }}.services.{{ service.name|snake_case }}.transports.{{ service.name }}Transport.__init__') as Transport:
        Transport.return_value = None
        transport = transports.{{ service.name }}Transport()

    # Every method on the transport should just blindly
    # raise NotImplementedError.
    methods = (
        {% for method in service.methods.values() %}
        '{{ method.transport_safe_name|snake_case }}',
        {% endfor %}
        {# TODO: Remove after https://github.com/googleapis/gapic-generator-python/pull/1240 is merged. #}
        {% if opts.add_iam_methods %}
        'set_iam_policy',
        'get_iam_policy',
        'test_iam_permissions',
        {% endif %}
        {% if not opts.add_iam_methods and api.has_iam_mixin %}
        {% if "SetIamPolicy" in api.mixin_api_methods %}
        'set_iam_policy',
        {% endif %}
        {% if "GetIamPolicy" in api.mixin_api_methods %}
        'get_iam_policy',
        {% endif %}
        {% if "TestIamPermissions" in api.mixin_api_methods %}
        'test_iam_permissions',
        {% endif %}
        {% endif %}
        {% if api.has_location_mixin %}
        {% if "GetLocation" in api.mixin_api_methods %}
        'get_location',
        {% endif %}
        {% if "ListLocations" in api.mixin_api_methods %}
        'list_locations',
        {% endif %}
        {% endif %}
        {% if api.has_operations_mixin %}
        {% if "GetOperation" in api.mixin_api_methods %}
        'get_operation',
        {% endif %}
        {% if "WaitOperation" in api.mixin_api_methods %}
        'wait_operation',
        {% endif %}
        {% if "CancelOperation" in api.mixin_api_methods %}
        'cancel_operation',
        {% endif %}
        {% if "DeleteOperation" in api.mixin_api_methods %}
        'delete_operation',
        {% endif %}
        {% if "ListOperations" in api.mixin_api_methods %}
        'list_operations',
        {% endif %}
        {% endif %}
    )
    for method in methods:
        with pytest.raises(NotImplementedError):
            getattr(transport, method)(request=object())

    with pytest.raises(NotImplementedError):
        transport.close()

    {% if service.has_lro %}
    # Additionally, the LRO client (a property) should
    # also raise NotImplementedError
    with pytest.raises(NotImplementedError):
        transport.operations_client
    {% endif %}

    # Catch all for all remaining methods and properties
    remainder = [
        'kind',
    ]
    for r in remainder:
        with pytest.raises(NotImplementedError):
            getattr(transport, r)()

{% if service.has_lro -%}
def test_{{ service.name|snake_case }}_rest_lro_client():
    client = {{ service.client_name }}(
        credentials=ga_credentials.AnonymousCredentials(),
        transport='rest',
    )
    transport = client.transport

    # Ensure that we have a api-core operations client.
    assert isinstance(
        transport.operations_client,
        operations_v1.AbstractOperationsClient,
    )

    # Ensure that subsequent calls to the property send the exact same object.
    assert transport.operations_client is transport.operations_client
{%- endif %}


@pytest.mark.parametrize("transport_name", [
    {% if 'grpc' in opts.transport %}
    "grpc",
    {% endif %}
    {% if 'rest' in opts.transport %}
    "rest",
    {% endif %}
])
def test_{{ service.name|snake_case }}_host_no_port(transport_name):
    {% with host = (service.host|default('localhost', true)).split(':')[0] %}
    client = {{ service.client_name }}(
        client_options=client_options.ClientOptions(api_endpoint='{{ host }}'),
        transport=transport_name,
    )
    assert client.transport._host == (
        '{{ host }}:443'
        {% if 'rest' in opts.transport %}
        if transport_name in ['grpc', 'grpc_asyncio']
        else 'https://{{ host }}'
        {% endif %}
    )
    {% endwith %}

@pytest.mark.parametrize("transport_name", [
    {% if 'grpc' in opts.transport %}
    "grpc",
    {% endif %}
    {% if 'rest' in opts.transport %}
    "rest",
    {% endif %}
])
def test_{{ service.name|snake_case }}_host_with_port(transport_name):
    {% with host = (service.host|default('localhost', true)).split(':')[0] %}
    client = {{ service.client_name }}(
        client_options=client_options.ClientOptions(api_endpoint='{{ host }}:8000'),
        transport=transport_name,
    )
    assert client.transport._host == (
        '{{ host }}:8000'
        {% if 'rest' in opts.transport %}
        if transport_name in ['grpc', 'grpc_asyncio']
        else 'https://{{ host }}:8000'
        {% endif %}
    )
    {% endwith %}

{% if 'rest' in opts.transport %}
@pytest.mark.parametrize("transport_name", [
    "rest",
])
def test_{{ service.name|snake_case }}_client_transport_session_collision(transport_name):
    creds1 = ga_credentials.AnonymousCredentials()
    creds2 = ga_credentials.AnonymousCredentials()
    client1 = {{ service.client_name }}(
        transport=transport_name,
    )
    client2 = {{ service.client_name }}(
        transport=transport_name,
    )
    {% for method in service.methods.values() %}
    session1 = client1.transport.{{ method.transport_safe_name|snake_case }}._session
    session2 = client2.transport.{{ method.transport_safe_name|snake_case }}._session
    assert session1 != session2
    {% endfor %}
{% endif -%}

{% if 'grpc' in opts.transport %}
def test_{{ service.name|snake_case }}_grpc_transport_channel():
    channel = grpc.insecure_channel('http://localhost/')

    # Check that channel is used if provided.
    transport = transports.{{ service.name }}GrpcTransport(
        host="squid.clam.whelk",
        channel=channel,
    )
    assert transport.grpc_channel == channel
    assert transport._host == "squid.clam.whelk:443"


{% if service.has_lro %}
def test_{{ service.name|snake_case }}_grpc_lro_client():
    client = {{ service.client_name }}(
        transport='grpc',
    )
    transport = client.transport

    # Ensure that we have a api-core operations client.
    assert isinstance(
        transport.operations_client,
        operations_v1.OperationsClient,
    )

    # Ensure that subsequent calls to the property send the exact same object.
    assert transport.operations_client is transport.operations_client

{% endif %}
{% endif %} {# if grpc in opts #}

{% with molluscs = cycler("squid", "clam", "whelk", "octopus", "oyster", "nudibranch", "cuttlefish", "mussel", "winkle", "nautilus", "scallop", "abalone") %}
{% for message in service.resource_messages|sort(attribute="resource_type") %}
def test_{{ message.resource_type|snake_case }}_path():
    {% for arg in message.resource_path_args %}
    {{ arg }} = "{{ molluscs.next() }}"
    {% endfor %}
    expected = "{{ message.resource_path }}".format({% for arg in message.resource_path_args %}{{ arg }}={{ arg }}, {% endfor %})
    actual = {{ service.client_name }}.{{ message.resource_type|snake_case }}_path({{message.resource_path_args|join(", ") }})
    assert expected == actual


def test_parse_{{ message.resource_type|snake_case }}_path():
    expected = {
    {% for arg in message.resource_path_args %}
        "{{ arg }}": "{{ molluscs.next() }}",
    {% endfor %}
    }
    path = {{ service.client_name }}.{{ message.resource_type|snake_case }}_path(**expected)

    # Check that the path construction is reversible.
    actual = {{ service.client_name }}.parse_{{ message.resource_type|snake_case }}_path(path)
    assert expected == actual

{% endfor %}
{% for resource_msg in service.common_resources.values()|sort(attribute="type_name") %}
def test_common_{{ resource_msg.message_type.resource_type|snake_case }}_path():
    {% for arg in resource_msg.message_type.resource_path_args %}
    {{ arg }} = "{{ molluscs.next() }}"
    {% endfor %}
    expected = "{{ resource_msg.message_type.resource_path }}".format({% for arg in resource_msg.message_type.resource_path_args %}{{ arg }}={{ arg }}, {% endfor %})
    actual = {{ service.client_name }}.common_{{ resource_msg.message_type.resource_type|snake_case }}_path({{ resource_msg.message_type.resource_path_args|join(", ") }})
    assert expected == actual


def test_parse_common_{{ resource_msg.message_type.resource_type|snake_case }}_path():
    expected = {
    {% for arg in resource_msg.message_type.resource_path_args %}
        "{{ arg }}": "{{ molluscs.next() }}",
    {% endfor %}
    }
    path = {{ service.client_name }}.common_{{ resource_msg.message_type.resource_type|snake_case }}_path(**expected)

    # Check that the path construction is reversible.
    actual = {{ service.client_name }}.parse_common_{{ resource_msg.message_type.resource_type|snake_case }}_path(path)
    assert expected == actual

{% endfor %} {# common resources#}
{% endwith %} {# cycler #}


def test_client_with_default_client_info():
    client_info = gapic_v1.client_info.ClientInfo()

    with mock.patch.object(transports.{{ service.name }}Transport, '_prep_wrapped_messages') as prep:
        {{ service.client_name }}(
            client_info=client_info,
        )
        prep.assert_called_once_with(client_info)

    with mock.patch.object(transports.{{ service.name }}Transport, '_prep_wrapped_messages') as prep:
        transport_class = {{ service.client_name }}.get_transport_class()
        transport_class(
            client_info=client_info,
        )
        prep.assert_called_once_with(client_info)


{% include 'tests/unit/gapic/%name_%version/%sub/_test_mixins.py.j2' %}

def test_transport_close():
    transports = {
        {% if 'rest' in opts.transport %}
        "rest": "_session",
        {% endif %}
        {% if 'grpc' in opts.transport %}
        "grpc": "_grpc_channel",
        {% endif %}
    }

    for transport, close_name in transports.items():
        client = {{ service.client_name }}(
            transport=transport
        )
        with mock.patch.object(type(getattr(client.transport, close_name)), "close") as close:
            with client:
                close.assert_not_called()
            close.assert_called_once()

def test_client_ctx():
    transports = [
        {% if 'rest' in opts.transport %}
        'rest',
        {% endif %}
        {% if 'grpc' in opts.transport %}
        'grpc',
        {% endif %}
    ]
    for transport in transports:
        client = {{ service.client_name }}(
            transport=transport
        )
        # Test client calls underlying transport.
        with mock.patch.object(type(client.transport), "close") as close:
            close.assert_not_called()
            with client:
                pass
            close.assert_called()

@pytest.mark.parametrize("client_class,transport_class", [
    {% if 'grpc' in opts.transport %}
    ({{ service.client_name }}, transports.{{ service.grpc_transport_name }}),
    {% elif 'rest' in opts.transport %}
    ({{ service.client_name }}, transports.{{ service.rest_transport_name }}),
    {% endif %}
])
def test_api_key_credentials(client_class, transport_class):
    with mock.patch.object(
        google.auth._default, "get_api_key_credentials", create=True
    ) as get_api_key_credentials:
        mock_cred = mock.Mock()
        get_api_key_credentials.return_value = mock_cred
        options = client_options.ClientOptions()
        options.api_key = "api_key"
        with mock.patch.object(transport_class, "__init__") as patched:
            patched.return_value = None
            client = client_class(client_options=options)
            patched.assert_called_once_with(
                host=client.DEFAULT_ENDPOINT,
                client_info=transports.base.DEFAULT_CLIENT_INFO,
            )

{% endblock %}
